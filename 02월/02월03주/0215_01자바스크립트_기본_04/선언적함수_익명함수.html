<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>익명함수 이름없는함수</title>
</head>
<body>
    

    <script>

        // '유즈 스트릭트';
        'use strict'; //엄격한 자바스크립트 모드
        
        // 1. 함수를 선언해서 만들고 
        // 2. 함수를 호출해야만 실행이 된다.
        // 3. 선언적함수는 함수의 위, 아래 어디서든지 호출 실행 가능.
        // 4. 익명함수는   함수의 아래에서만 호출 실행 가능.



        // 선언함수의 위, 아래 어디든지 위치에 관계없이 호출 가능하다.
          // func2();
        //    function func2(){ //선언적 함수
        //     let a = 400;
        //     let b = 500;
        //     return console.log(`선언적함수 리턴값 ${a+b}`);
        // }





        // 익명함수 변수 = function(){}
        
        // const func1 = function(x, y){ //매개변수 2개
        //     let a = x;
        //     let b = y;
        //     return console.log(`익명함수 리턴값 ${a+b}`);
        // }

        // func1(78,99); //전달인자 아규먼트 2개 
        // func1(100,299); //전달인자 아규먼트 2개 

        // 익명함수 실행은 반드시 함수 선언 아래에서만 가능하다. 
        // func1(); 위에서 호출시 오류발생. 반드시 아래에서만 가능하다. 


        // function 키워드는 함수에 기본 키워드
        // 화살표함수 ES 6 Next 익명함수 아래에서만 호출 가능!!!! 

        // function fn() {

        // }

        // const func2 = (x, y)=>{}

        // const fn=()=>{

        // }
        // const fn1 =()=> { 

        // }

        // 즉시표현함수식 화살표 함수

        // (function fn() {

        // })();
        
        // 화살표함수식 변경 

        // (()=>{ 

        // })();

        // 화살표함수 실행 

        //1
        const 함수1 = (pa1, pa2) => { // 매개변수 
            console.log('함수1 내부 파라미터값 출력',pa1,pa2); //리턴이 필요없이 함수 안에서 바로 결과 출력
        }
        함수1(9,99); //아규먼트 (전달인자)
    
        //2 아래는 모두 리턴 결과
        const 함수2 =(pa)=> {
            return pa + 100; // 결과를 되돌려 받을 때 리턴 필요하다. 
        }
        console.log('함수 밖에서 결과 출력',함수2(9 , 99));

        //3 블록을 생략하고, 리턴문을 생략하여 한줄로 표기 사용가능하다. 
        const 함수3 =(pa)=> pa + 100; // 한줄 코딩 화살표함수는 즉시 리턴이 이루어진다. 

        console.log('함수 밖에서 결과 출력',함수3(9, 99));


        //4 파라미터가 1개인 경우는 괄호를 생략할 수 있다. 
        //단, 파라미터가 2개 이상인경우는 반드시 소괄호를 사용해야 한다. 
        const 함수4 =pa => pa + 100;  
         
        console.log('함수 밖에서 결과 출력',함수4(9, 99));

        //프로미스 비동기처리할 때는 반드시 화살표함수 사용

        // 배열과 객체 그리고 함수 
        const obj1 = {상품코드:'PRODUCT001',상품명:'딸기',가격:'25000'}
        상품(obj1);
        function 상품(obj1){
            console.log(obj1.상품코드);
            console.log(obj1.상품명);
            console.log(obj1.가격);

        }

        // 상품2(obj1);
        
        // const 상품2=(obj1) => {
        //     const {상품코드, 상품명, 가격} = obj1;
        //     console.log
        //     console.log
        //     console.log
        // }

        
        // function 상품2(obj1){
        //     const {상품코드,상품명,가격} = obj1 ; // 비구조화 => 구조분할할당
        //     console.log(상품코드);
        //     console.log(상품명);
        //     console.log(가격);

        // }

        // 상품3(obj1);

        // const 상품3=({상품코드,상품명,가격})=>{ // 비구조화 => 구조분할할당
        //     console.log('매개변수에서 비구조화',상품코드);
        //     console.log('매개변수에서 비구조화',상품명);
        //     console.log('매개변수에서 비구조화',가격);
        //   }
    

          // 화살표 함수 이용 배열값 검색
          const arr = ['이동희','김유신','정슬기','김두환'];

        //   const result = 배열이름.map(function(){});
          //const result = 배열이름.map((item)=>item==='김유신'); //중괄호를 빼면 즉시 리턴
          const result = arr.map((item)=>item==='김유신'); //중괄호를 빼면 즉시 리턴
          console.log (result);
          // 결과 result[false, true, false, false];
          // console.log (result.includes(true) ? 'true' : 'false');
          console.log (result.includes(true) ? '김유신 찾았다' : '김유신 없다');




        // 배열을 맵함수를 이용 김유신을 검색 찾으면 true 아니면 false를 반환
        // === >= <= > <     !== 같은 것이 아님. 논리값 true 또는 false 
        // 배열안에 특정한 글자가 포함된 것 비교. 




    </script>



</body>
</html>